<!doctype html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="description" content="Makes cool shit." />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <title>Serverless Upload to Object Storage</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="Kevin Hoyt" href="/feed.xml" />  

  <link rel="stylesheet" href="/style/kevinhoyt.css" />
  <link rel="stylesheet" href="/style/header.css" />
  <link rel="stylesheet" href="/style/article.css" />
  <link rel="stylesheet" href="/style/footer.css" />
  <link rel="stylesheet" href="/style/prism.css" />  

</head>
<body>
  
  <header >
  <div>
    <p><a href="">Kevin Hoyt</a></p>
    <a href="https://twitter.com/krhoyt">
      <img src="/img/twitter.svg" width="16" height="16" />
    </a>
    <a href="https://github.com/krhoyt">
      <img src="/img/github.svg" width="16" height="16" />
    </a>      
  </div>
  <div>
    <h2>Kevin Hoyt</h2>
    <h3>The intersection of development and design.</h3>
  </div>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/events">Events</a></li>
    <li><a href="/lounge">Lounge</a></li>
  </ul>
</header>


  
  <main>

    <img src="" alt="Serverless Upload to Object Storage">
    <article>
      <h1>Serverless Upload to Object Storage</h1>
      <p>So there you are, building the world's next breakthrough social platform. And of course you want to minimize cost, administration, etc. so you use <a href="https://console.bluemix.net/openwhisk/">IBM Cloud Functions</a> (<a href="https://openwhisk.apache.org/">Apache OpenWhisk</a>). Then you decide to let users manage their profile picture. Uploading a file to a Cloud Function takes some consideration - and then there is the problem that the environment will destroy itself, and the uploaded content, after execution. In this post, we combine <a href="https://www.ibm.com/cloud/object-storage">IBM Cloud Object Storage</a> with Web Actions for robust, persistent storage.</p>
<h2>HTTP Multipart Request</h2>
<p>Most web developers will think of this as submitting an HTML form - often for the purposes of uploading files. When we look at the content going across the wire, you will first see a typical HTTP header, with one notable addition. There will be an entry in the header for the &quot;boundary&quot; of the various pieces of content. Then as you look trough the rest of the request, you will see that boundary marker between each distinct item being sent - a form field, and a file, for example.</p>
<p>From an example shown on <a href="https://stackoverflow.com/questions/913626/what-should-a-multipart-http-request-with-multiple-files-look-like">Stack Overflow</a>:</p>
<pre><code>POST /cgi-bin/qtest HTTP/1.1
Host: aram
User-Agent: Mozilla/5.0 Gecko/2009042316 Firefox/3.0.10
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://aram/~martind/banner.htm
Content-Type: multipart/form-data; boundary=----------287032381131322
Content-Length: 514

------------287032381131322
Content-Disposition: form-data; name=&quot;datafile1&quot;; filename=&quot;r.gif&quot;
Content-Type: image/gif

GIF87a.............,...........D..;
------------287032381131322
Content-Disposition: form-data; name=&quot;datafile2&quot;; filename=&quot;g.gif&quot;
Content-Type: image/gif

GIF87a.............,...........D..;
------------287032381131322
Content-Disposition: form-data; name=&quot;datafile3&quot;; filename=&quot;b.gif&quot;
Content-Type: image/gif

GIF87a.............,...........D..;
------------287032381131322--
</code></pre>
<p>When this content arrives at the traditional middleware, such as Express on Node.js, the boundary label is found, and the request is parsed to get the parts. Parts are then placed in variables relative to how the middleware functions. In the context of a Cloud Function however, there is no Express to parse the request, so we need to (a) get access to the raw HTTP content and (b) parse it ourselves.</p>
<h2>Upload to Cloud Function</h2>
<p>If you are familiar with the CLI for Cloud Functions, you may already be familiar with the &quot;--web&quot; argument, which allows you to expose the function to HTTP endpoints. There is a &quot;raw&quot; addition that can be made to this argument to enable raw handing of the HTTP content. With this change the function will receive the raw HTTP string, not an object that has already been parsed. And this is exactly what we want.</p>
<pre><code>ibmcloud fn action create cos/post.object --kind nodejs:8 action.zip --web raw
</code></pre>
<p>Note that this setting can be found in the IBM Cloud Functions web-based UI as well. Select an action and then &quot;Endpoints&quot;. In fact, I prefer the web UI for tweaking actions once they have been created.<br>
<img src="/content/images/2019/01/post.object.web.ui.png" alt=""></p>
<h3>Parsing the HTTP Content</h3>
<p>When I originally started down this path, I was determined to parse the HTTP content myself. After all, the boundary is called out right there in the header. How hard could it be to find the boundary in the body and parse it myself? It turns out that there are a lot of edge cases that make this harder than it sounds. In the end, I turned to the &quot;<a href="https://github.com/chjj/parted">parted</a>&quot; library for help, with a special assist from &quot;<a href="https://github.com/feross/string-to-stream">string-to-stream</a>&quot;.</p>
<pre><code>const multipart = require( 'parted' ).multipart;
const sts = require( 'string-to-stream' );

let decoded = new Buffer( params.__ow_body, 'base64' );
let stream = sts( decoded );

const options = {
  limit: 30 * 1024,
  diskLimit: 30 * 1024 * 1024
};

let parser = new multipart( 
  params.__ow_headers[ 'content-type' ],
  options
);
let parts = {};

parser.on( 'error', function( err ) {
  console.log( 'parser error', err );
} );

parser.on( 'part', function( field, part ) {
  parts[field] = part;
} );

parser.on( 'end', function() {
  console.log( 'File upload complete.' );
} );

stream.pipe( parser );
</code></pre>
<p>The first step here is to decode the HTTP request body, and create a stream from it. Then we set aside a splash of disk space. Up next is the actual parsing of the body. Various events occur during the parsing, most notably, when the parsing process has ended. When the parsing ends you will have a &quot;parts&quot; variable with properties reflecting the various names of the fields that were provided when the request was made.</p>
<p>That is to say that if you have <input type="file" name="picture"> then you will have a &quot;parts.picture&quot; property containing the file contents. You can then choose to write it to disk, send it on to another service for further processing, etc.</p>
<p>Of course as a user profile picture, or other file type you may want to keep around for some duration, writing the contents to disk is not going to do you any good. That content will be destroyed along with the Cloud Function once the processing has finished. We really need to put the file somewhere reliable - such as IBM Cloud Object Storage.</p>
<h2>Upload to Object Storage</h2>
<p>Under the covers, IBM Cloud Object Storage (COS) is <a href="https://wiki.openstack.org/wiki/Swift">OpenStack Swift</a>, and conforms to the interface established by AWS S3. You create buckets, and put objects in the buckets. There are SDKs available in various languages, but we are going to continue along the Node.js path. There is a specific <a href="https://github.com/ibm/ibm-cos-sdk-js">fork</a> of the S3 library for COS which I recommend using for the most consistent results.</p>
<h3>Instantiate COS</h3>
<p>The first step in using the library is to instantiate it as a client. A quick look at the documentation for the library shows that we need &quot;endpoint&quot;, &quot;apiKeyId&quot;, and &quot;serviceInstanceId&quot; values. For me, finding the right pieces in the UI took some effort the first time.</p>
<pre><code>let cos = new AWS.S3( {
  endpoint: '&lt;endpoint&gt;',
  apiKeyId: '&lt;api-key&gt;',
  ibmAuthEndpoint: 'https://iam.ng.bluemix.net/oidc/token',
  serviceInstanceId: '&lt;resource-instance-id&gt;',
} );
</code></pre>
<p><strong>Endpoint</strong></p>
<p>When you are looking at the list of buckets, you will see a &quot;Location&quot; column. The bucket I am using for this example sits in &quot;us-east&quot;. Click on &quot;Endpoint&quot; in the left sidebar. When I created the bucket, I selected &quot;Regional&quot; resiliency, so I will select &quot;Regional&quot;. Then select the corresponding location such as &quot;us-east&quot;. We will be using &quot;Public&quot; access, which in the case of &quot;us-east&quot; yields &quot;s3.us-east.cloud-object-storage.appdomain.cloud&quot;.</p>
<p><strong>API Key</strong></p>
<p>Next we will head to the &quot;Service credentials&quot; section by clicking on that link in the left sidebar. You may have a number of credentials, each will have the option to &quot;View credentials&quot;. Expanding this section yields a section of JSON. Look for the field labeled &quot;apikey&quot;.</p>
<p><strong>Service Instance ID</strong></p>
<p>The &quot;resource-instance-id&quot; is found in this block of JSON-formatted credentials as well.</p>
<h3>Put an Object</h3>
<p>Putting an object into COS looks exactly like it would if you were using the AWS S3 SDK. On the COS client you call &quot;putObject()&quot; with the content you want to store, the bucket in which you want to store it, and the name of the content itself.</p>
<pre><code>let obj = fs.readFileSync( parts.file );

await cos.putObject( {
  Body: obj,
  Bucket: 'file-upload',
  Key: parts.name   
} )
.promise()
.then( ( data ) =&gt; {
  console.log( 'File storage complete.' );
} );
</code></pre>
<p>When we uploaded the file from the browser (or other client) to the Cloud Function, we ended up with a &quot;parts&quot; object holding the file contents in a &quot;file&quot; property (which came from the name of the HTML input). To get this ready for storage, we read it into a Buffer object and provide that as the &quot;Body&quot; parameter.</p>
<p>The &quot;Bucket&quot; name should match the desired bucket from your COS instance. You can name the file whatever you need to for your application. &quot;Key&quot; is equivalent to &quot;name&quot; in the COS/S3 model. For the purposes of flexibility, I like to send the name along with the file - effectively, I like to make the name a parameter on the service.</p>
<blockquote>
<p>The &quot;putObject()&quot; call is using &quot;async/await&quot;. If we do not wait for the upload to finish, the function will terminate before the file ever gets uploaded.</p>
</blockquote>
<h2>All Together Now</h2>
<p>Now that we know how to upload, and parse, a file to a Cloud Function, and how to then put the file onto Cloud Object Storage, all that is left is to string the bits together.</p>
<pre><code>function upload( params ) {
  const AWS = require( 'ibm-cos-sdk' );
  const fs = require( 'fs' );
  const multipart = require( 'parted' ).multipart;
  const sts = require( 'string-to-stream' );

  return new Promise( ( resolve, reject ) =&gt; {
    let decoded = new Buffer( params.__ow_body, 'base64' );
    let stream = sts( decoded );

    let parser = new multipart(
      params.__ow_headers[ 'content-type' ], {
        limit: 30 * 1024,
        diskLimit: 30 * 1024 * 1024
      }
    );
    let parts = {};

    parser.on( 'error', function( err ) {
      console.log( 'Whoops!', err );
    } );

    parser.on( 'part', function( field, part ) {
      parts[field] = part;
    } );

    parser.on( 'end', async function() {
      let cos = new AWS.S3( {
        endpoint: params.COS_ENDPOINT,
        apiKeyId: params.COS_API_KEY,
        ibmAuthEndpoint: params.COS_AUTH_ENDPOINT,
        serviceInstanceId: params.COS_SERVICE_INSTANCE
      } );
    
      let obj = fs.readFileSync( parts.file );
    
      await cos.putObject( {
        Body: obj,
        Bucket: params.COS_BUCKET,
        Key: parts.name
      } )
      .promise()
      .then( ( data ) =&gt; {
        resolve( {
          headers: {
            'Content-Type': 'application/json'
          },
          body: data
        } );
      } );
    } );

    stream.pipe( parser );
  } );
}

// Do not forget to export
exports.main = upload;
</code></pre>
<p>There are some particularly important details to consider when putting everything together. The first is that the main function returns a &quot;Promise&quot;. This is done to keep the function running until a result is ready. Without this promise, the function would terminate and the file would (a) never get parsed and (b) never get stored.</p>
<p>The other important detail comes up in the &quot;end&quot; callback of the parsing operation. The function provided is marked as &quot;async&quot;. The reason for this is that the COS operation is promise-based. And again, if we do not wait for it to finish, the function will return before the file is stored. The means we need to use the &quot;await&quot; keyword. The &quot;await&quot; keyword can only be used inside an &quot;async&quot; function.</p>
<p>It is probably worth noting that I put my COS credentials in parameters provided to the function. I do not however expose those parameters to the client. Those parameters are provided at the function level. You can do this on the CLI, or in the Cloud Functions UI tooling. I prefer the tooling when working with very long strings like the ones needed for COS connectivity. YMMV.</p>
<h2>Next Steps</h2>
<p>Now that we know how to get a file up to IBM Cloud Object Storage via IBM Cloud Functions, the next step is to get it back down. I will go over what this looks like in my next post. This will give us the &quot;read&quot;, &quot;edit&quot;, and &quot;add&quot; operations of BREAD. A little further on, and we can &quot;browse&quot; and &quot;delete&quot;. Then we can piece together a full file management system built using serverless.</p>

    </article>
  </main>
          

  <footer>
  <p>
    <a href="https://kevinhoyt.com">Kevin Hoyt</a>
    <span>&copy; 2021 - Published with</span>
    <a href="https://www.11ty.dev">Eleventy</a>
  </p>
</footer>


</body>
</html>
